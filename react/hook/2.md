什么是好的架构？
好的架构让你的代码从笔尖中往外蹦出,而不用每次实现都从脑子中一点点挤出。
好架构让新需求好像也在古老的设计之中。
在好的架构下，实现ssr只不过是最后一步水到渠成。

代码分层。
server层封装。
context层。
render层（component层）


part1
架构梳理


Hook Part
Hook Intro


1）基于Hook的数据流。

他的特点如下。
1.多仓库。
2.


SSR只是最后一个步骤，最后一个环节。
SSR的本质是，我们知道，React是JS渲染出来的，也就是js通过执行createElement，将json转化为dom，最终替换掉根节点root，来达成js渲染dom的目的。那么当js没有执行的时候，实际上我们的index.html是一个空页面。
SSR就是在服务端，执行了js代码，来未卜先知的将预期的页面渲染出来。这样前端拿到的不再是一个空的HTML，而是一个，会根据用户路由，特定渲染出来特定页面的，有血有肉甚至还有请求数据的HTML。
它分为几个步骤。
1）路由匹配阶段，获取页面，获取同构函数ssr.js。
2）调用页面请求，获得数据
3）注入数据，进行渲染
4）最后将数据注入到HTML中，HTML作为信使，将内容带回client
一个React应用就是一个大递归函数，传入数据，就会渲染出固定的视图。在client，我们通过请求，用户交互来获取数据。而在server端，我们通过设置store来实现页面的渲染。
这里面有一些技术细节
1）如何让所有的子仓库，获得ssrData？
三大戒指归属天下精灵诸君，七大戒指归属石厅矮人列王，九枚戒指归属于阳寿可数的凡人，还有一枚归属于高居御座的黑魁首。莫都大地黑影幢幢。一枚戒指统领众戒，尽归罗网。

这块借鉴了flux，在flux里面，虽然有众多的store，但是有一个controller在上面统帅着所有人。因此，这里实际上每个store，都监听了SSRDATA。更准确的说，使用useGetSSRDATAHook来执行，在reducer初始化的时候，将数据进行初始化注入。

2）如何不重复的拉取请求？
那么我们的请求代码分为三块。
1）server端执行同构函数。
2）client端，执行同构函数（如果server端失败，或者关闭了ssr的情况下）。
3）client端正常运行的请求。

1）如何拆分代码。
这里有一个share的概念，

首先，SSR的代码肯定需要在server端运行。
但是往往SEO首屏的复杂度是有限的，我们需要多少动态内容，就运行多少接口。然后把这些接口返回给Client端
因此我们应该尽量复用server。这样在server端就能用最少的代码，拉到最终符合store要求的数据。





3）如何控制非SSR渲染的页面。
并不是所有页面ssr都有意义。
可以从routerConfig中配置一下。非SSR页面，可以返回一个相同的loading页面。



2）如何根据请求判断机型来渲染
在req.header中有agent相关信息




ssr的细节
在同构函数中，我们得不到store dispatch的帮助。因为根本就执行不到，他基本上就是同步执行。你只能通过async来组织逻辑.简单来说,ssr的数据流转,和app不太一样.

我是怎么理解ssr的?
我目前对他的理解是,哪些可以同构,哪些不能同构?
可以同构
所有的渲染,所有的dom结构

哪些不可以
请求数据流不可以.
原因:因为SEO在node端分为两个阶段.对于浏览器来说,生命周期,拉取,都是异步的.对于node ssr来说,全部都是同步的.所以这两个事情根本没办法同构
步骤1:数据的准备
步骤2:扔给app组件,完成整个DOM的同步渲染.
这个渲染过程中没有异步,他会立刻得到一个html文件,并且返还给我们的前端.
那突破点在哪里?在于他们的共同点是:有数据从props提供过来,都能完成相同的同构渲染.因此在Server端,数据的构建是单独的脚本完成的.这个脚本做各种的ajax,数据处理,数据交互,然后返回一个可以被redux接纳的数据结构,完成渲染.
在我的架构里面,我用一个单独的ssr文件来完成这个过程.每一个ssr页面,都需要准备这样一个ssr脚本,让他在Node端运行的时候,可以提前获得Redux所需要的数据,从而填充进去完成渲染.

我们可以再来看一下.有三类请求
1)只在客户端发生的请求
正常交互就会发生的.在spa应用中站主要地位的
2)只在服务端发生的请求
专门为爬虫,首屏渲染内容,前端数据拉取所服务的.为了首屏而生.那么他基本上没有交互后的次生请求,都是第一次发起的.
因此我们可以看出,ssr脚本的编写,虽然必然是重复的,但是他有很强的确定性.我们就像是一个导演,我们正在自编自导一部专门表演给爬虫还有首屏用户的一个页面.一个用户进入一个页面需要进行的一系列操作,都是确定的,顺序的,必然会发生的.
因此他虽然重复,但是好写.
因此要求我们什么?最理想的情况就是,除了调用的那一行代码以外,其他所有的代码都是纯函数,都是脱离于执行环境的.实际上肯定不可能,前端拿到的请求结果,需要dispatch到store中.
而我们在node端,都是拿好请求结果,赶紧扔给redux,再在最后交还给html完成数据注入.两个逻辑完全不一样.
3)在两端都会发生,都会需要他们发生的请求

ssr这篇文章,分为若干个章节
1)从一个div说起
2)从一个请求行为说起
3)从一个数据的前世今生说起
4)从架构说起,为什么多仓库有好处?或者说,为什么将请求数据放到context中有好处?
5)可以思考下,next是如何如此优雅的实现的?
前面提到,所有的请求性质的数据和行为,都保存在了store中,那么究竟为什么要这样做?假设我们要做ssr.我么需要什么?
1)我肯定需要将状态和渲染剥离,我需要一些纯组件,来完成数据注入渲染.
2)因为我在服务端,是没办法在页面上发起请求的,数据是我单独组织好,从最顶层注入进去的.因此,我必须有全局层面的数据存储渲染层.
3)我需要尽可能复用一些请求.还有数据处理,因为这部分代码是必然需要重写的
4)杜绝代码侵入.让ssr的代码可以随时离开.至少不会引入bug

SEO的本质是，浏览器有一个disable的模式，开启了之后，就是爬虫视角。要始终记住的就是，爬虫是不喜欢js的。因此他没有办法运行onClick回调