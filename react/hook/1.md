## 请求如何发起





从上篇的话题继续聊,我们从一个例子入手;
有这样一个简单的搜索列表页.getList被8个前端状态变量控制.究竟该如何设计这个请求模型呢?说实话,一年前,我真的不知道怎么写.React的核心之一是啥?是 view = render(state).不讨论请求,都还好.如果呢?那么 改变了 state 自动调用ajaxview = render(state)state = ajax(userInputState)我用什么描述下面这行呢.你聪明的.我们在didUpdate里面监听,然后再发起.那如果view = render(state)state = ajax(state)state = ajax(state)state = f(userInputState)怎么做?如果这部分代码,要服用,怎么做?用hooks会简单很多.因为我们有useEffect(ajax, [state])start ajax = render(state)我不知道dom是如何渲染出来的.但我知道state是如何变化的我不知道请求是如何发起的.但是我知道这个ajax需要哪些state作为依赖.因此,我只需将所有的请求,都包装在useCallBack中就可以了.实际上,最浅的useEffect就是纯函数,不依赖于任何东西.最深的useEffect就是将所有的state,甚至其他的useCallBack函数都融合在一起的.最纯的自然好,但是你需要传递很多东西进去.融合的自然好,但是当你需要剥离状态的时候就很艰辛了.我个人实践上来说,如果不考虑ssr,我所有的都用actions描述是ok的如果考虑ssr或者其他模块的复用,我会做纯化的处理.![ff422aa78868f69fac220616a81b7bc3.png](en-resource://database/4656:1)
最后就抽象成这么一句话.他封闭了所有的内部复杂度.讽刺的是,如果要在node端复用,这些复杂度,似乎一个都跑不了.因为服务端拉取和渲染是两个部门在做.![e2563b3d5bab812c686cf061dbd498fc.png](en-resource://database/4658:1)
极限抽象的store,只剩下一些定义.连数据回补都显得非常的轻描淡写.![98b86c13474d3598446f0b73e64825bd.png](en-resource://database/4660:1)
尽量让dep中只有状态,没有其他依赖,这样就会变得很清晰.如果各个state之间,没有依赖,那就非常棒.如果有依赖,其实也不爬应该是![1cb30c8526b413ad6718da1501524690.png](en-resource://database/4662:1)
一个函数,只要控制好依赖,如果他是仅仅由传入决定了传出,那么无论它内部实现有多少业务,多少逻辑,都不可怕.因为只管调用就可以了.怕的就怕在闭包下,复杂的依赖关系.所以将过度复杂的业务逻辑,扔到action之外,作为纯函数存在.action只描述最核心的业务流转.不描述业务处理细节.这是非常重要的一层抽象具体来讨论,分为这么几步0)ts定义函数结构1)useCallBack包装2)打出去3)通过state这种方式暴露给子组件,在引入context的时候调用.它本质上是请求的业务包装体,他抽象了1)数据组织2)数据拉取3)数据赋值而相对的,server层仅仅负责数据拉取.我们最终的action本质是什么?本质是封装了state,其他的actiondispatch还有请求.请求的处理(不包括请求的清洗.那个被剥离到util.尽量在server中调用来使用)## 为什么要用useEffect进行封装?因为,useGetAction函数,获得了若干个,依赖于状态的请求包装体.当这些state发生变更的时候,他们需要重新拉取.传统的思路是,提供出来的action是相对静态的.我只管进行调用就可以了.最后一些坑的分析和分享1)无线循环的发生.2)依赖关系不清晰.3)请求莫名其妙就被发起.一些其他的业务问题如何来调和临时数据和全局数据的矛盾如何解决无法跟随数据而发生的effect,例如跳转?在最后,上一个内容,前端ssr介绍再最后一个篇章,结合这个架构来实现ssr没有讨论完的问题。4）如何处理异步我们通过actions处理异步。acitons触发dispatch。dispatch触发新的actions。而页面去消费结果。你们描述顺序步骤执行，描述回调关系我们描述关系和响应1）在哪里发请求。（顺序与关系）在Hook的世界里，我找到了不同的答案。在class里面，我们习惯在componentDidMount事件钩子里面发起请求。我不讨厌钩子，但是这种并不优雅。有几个原因：1）React是状态驱动的。而钩子，本身就不算是一个纯粹的状态，钩子里面调用一个请求，也是命令形式的。就例如，显示一个弹框组件，我们可以通过设置visible，修改状态来获得。也可以通过Modal.confirm方法，命令式的生成。我们喜欢使用state来控制modal，而不是命令式。2）对于抽象不够灵活抽象一个生命周期并不轻松。我们可以通过Hoc来做。我比较菜，因而我觉得Hoc这样比较重。那么到了Hook的时代，有了useEffect这个强大的函数，有什么新思路吗？思路1：useEffect里面发起ajax。useEffect(() =&gt; { ajax1(); }, [])最直白的思路，但是这不够好。这本质上还是在用命令式。这样就换汤不换药了。不能让useEffect去执行复刻我们的生命周期，我们不能用老的的思维（生命周期）理解新的抽象（函数式）。另外，由于hook里面，setState是没有回调函数的，有时候根本就写不出来。例如，进入页面设置A，A设置后用A请求B，B得到后用B请求C。我们async写不出来，因为没有回调。useEffect(() =&gt; { ajax1(url).then((res) =&gt; { setData(res) }) }, []) useEffect(() =&gt; { ajax2(); }, [])我们举一个最基本的例子。用户使用skuId进入我们的商品页。我们通过skuId获取detail详情。那么skuId是有资格作为全局的。(实际上我修改了之后,废弃了.他根本没理由也没必要成为全局,他自己直接用skuId调用接口就足够了.我没有必要强行用一个不配成为状态值的东西,包装成状态值,实现需求)所以我们应该先监听parmas，然后赋值给skuId。(我们监听prarms,然后一旦pramas变化,我们就直接使用useEffect触发后续流程)在使用useEffect监听skuId，发起getDetail接口。而一变皆变指的就是这种依赖更新的现象。一空皆空值得就是依赖的逻辑判断性解决这种问题或者说，如何发起请求才优雅？（TLDR）1）永远不要在useEffect中直接发起ajax(那要如何发起?我们要在useEffect里面调用完全响应式的useCallBack包装体)这一点实际上非常难做到。我觉得，只要不造成幽灵（也就是，被遗忘在过去的值。），这个问题应该不大。实际上，如果你不避免的话，他的问题确实非常大。因为你所有的依赖就不可靠了。所以我觉得可以变为。dispatch不回调。回调不dispathc。两者只能选其一。如果既有dispatch，又想拿到回调呢？那恐怕不可能。(但是这个问题,的确在,需要点击提交的场景下,来解决.并且我现在解决的也不是非常好,就是因为我缺少一个驱动他的状态.)我之所以想避免，是想用纯粹的状态来驱动。发起后然后回调，不够好。2）如果有状态值的话，去通过dispatch设置状态值3）通过useEffect，监听状态值的变化，发起ajax其实在页面的情况下，这就是我们的实践。但是这个[]有点丑陋。（这块实际上是我架构的核心，应该扔上去一张图。）这种流式请求会带来几个问题2）关系不清晰例如你很难看到有一行代码表现，当进入这个页面的时候，刷新页面的数据。取而代之的是一些逻辑关系，当进入页面的时候，判定currentPage成功，设置pn。pn又让我们发起了请求。这样的缺点是有的，啰嗦，并且关联不明显。但我觉得可以接受，我并不觉得，会有很多层的关联关系和状态。(但是他的优势是,描述关系,要比描述流程,更容易维护,编写复杂代码更灵活.这个缺点,的确存在,但是能够被控制1)尽量闭合在本地.2)全局useEffect注意设置条件)（猜测：因为我觉得，如果有复杂的相互关联，其实流是好描述的，常规基于顺序的描述也许更困难）1）请求不好控制。例如你会在任何页面莫名其妙的发起了任何的action。这也是dep的设计价值我认为。因此我的方案就是，通过使用dep和condition其实写到这里我发现，这两个概念被惊人的抽象在一起了。一个函数里面用到的所有变量，必然是这个函数的dep，这是一种很神奇的现象。非常优雅。这样我们专注在condition就行了。对的，条件和依赖可以统一。一个函数所需要的条件，就是为了保证他时刻是最新的所要付出的依赖代价。这两个无论是在lint规则还是道理上，都是成立的。条件，一定是依赖的一项。更直白的说（可以看下大神的理解）：条件就是依赖。（这是我的理解）大神的理解是，useEffect是用数据流伪装好的，被状态驱动的，额外行为，他将函数的触发，统一到了状态驱动上条件一定是dep，但是dep不一定是条件，例如，a,b,c变化的时候，请重置z，条件和依赖的关系就不是非常明确了。3）多重链式依赖这里面有一些坑1）严格按照依赖来写2）尽量解耦各个依赖，不要把链路拉的太长。3）当出现多次调用一个dispatch的时候，再检查一下依赖依赖里面有一些很复杂的问题。就是链式依赖。这也是我至今没想好思路的地方。a-&gt;bb-&gt;cc-&gt;ajax如果有一天，a和b同时变化，会怎么样。会发起两个ajax。并且合情合理。但是不符合用户期望。这里面有个法则。当abc，生成d的时候，不允许再次出现abc之间的依赖关系，例如，a-&gt; b，不然a的变化，必然会引起d的两次变化。(经过实践我发现,多重依赖根本没办法避免.他就像一个webpack一样,任何一个依赖变化,都必然会引起重新打包.我根本没办法判断,应该否决掉哪个打包行为.这种写法,如果ajax有节流,并不会引发问题我个人觉得.因为实际上,我们只应该关心最后的结果,而忽略中间的过程./)(实际上,多重触发不是问题.他就相当于是rerender一样.既然依赖于状态,那么状态改变必然带来重新的触发调用.这并不会引起bug.)part1我觉得这个问题我并没有解决。这个问题还是存在。使用中间变量，没办法让我获得所有的所哟的后续依赖。而且他的状态还得做好清空的准备。dispatch发起请求很轻松，但是回调并不好拿到。因为dispatch本身就没有回调函数。想想看，我发起了一个dispatch，我怎么会知道他背后导致了多少useEffect的事件，更不用说拿到其中任何一个的报错或者成功的状态了。一般来说，我们尽量能不拿就不拿。但是有时候，就是需要拿，怎么办。这里面有使用的方法是，用了ref作为中间变量。返回的时候，返回了一个promise，当在过程中发生变更的时候（例如报错了）我们通过修改这个promise的状态来实现。这样折腾就是为了，让dispatch行为，可以有一个对应的结果。其实我觉得更优雅的思路是，每个action都对应着一个promise。可以轻松获取请求的一连串后续，并且，可以用于储存私有的loading状态。part2 数据缓存。前端缓存数据，往往会有更多的问题。我没找到很好的机制。但是至少我可以说，有一些，被依赖随时修正的数据，是不能随手加缓存的。part3 如何控制好loading和报错状态loading这个事情，我似乎没找到更加优雅的思路。如果我能够给每个请求，都分配一个promise就好了。目前的做法就是请求前 set一下 请求结束后 再set一下。part4 报错处理报错做了简单的分层。基本上是自己处理自己的报错。4）终极问题，如何发起请求如何用hook写出来一个漂亮的请求1）这段代码在任何地方，都能运行并有相同的结果。这也强化了，[] !== didMount的含义。因为这种写法放在全局肯定是有问题的，他其实省略了一些语意（当第一次执行的时候，请执行）但是我们大部分时候，还是不愿意乱写的。那些写在全局，那些写在页面呢？首先能写在页面的，一定可以写在全局。写在页面相当于节约了一个是否在当前页面的判断条件。因此我觉得可以改成，能写页面就写页面。页面不好写就写全局。或者可以说，一定有一个页面依赖的情况，就写在页面好了。不然就写在全局。其实这个事情没有定论，归为个人习惯吧。我觉得还有个思路是，业务性的主动请求，放在页面里面。次生的请求，放在全局上面。(其实原则很简单.最小区域原则.如果仅仅在页面发生,如果仅仅在路由模块发生,如果跨模块全局发生)我觉得请求分为三类。1）点击事件的请求，他们是命令式的，所以需要马上调用。(这类请求,最难以处理好.他们的难点往往在于状态的提交.)2）进入页面，就运行的请求，他们是写在页面水平的，useEffect触发(这类的难点在于,容易莫名其妙的触发)3）次生效应的请求，他们(这类的难点在于,难以追述)写在哪里是一个问题。xx是另外一个问题