 什么是好的架构？
好的架构让你的代码从笔尖中往外蹦出,而不用每次实现都从脑子中一点点挤出。
好架构让新需求好像也在古老的设计之中。
在好的架构下，实现ssr只不过是最后一步水到渠成。

代码分层。
server层封装。
context层。
render层（component层）


part1
架构梳理


Hook Part
Hook Intro


1）基于Hook的数据流。

他的特点如下。
1.多仓库。
2.

----




2）如何不重复的拉取请求？
那么我们的请求代码分为三块。
1）server端执行同构函数。
2）client端，执行同构函数（如果server端失败，或者关闭了ssr的情况下,实际上ssr里面的所有逻辑都是为了首屏而服务.实际上server挂了的话,这个也没必要执行了）。
3）client端正常运行的请求。

我们可以再来看一下.有三类请求
1)只在客户端发生的请求
正常交互就会发生的.在spa应用中站主要地位的
2)只在服务端发生的请求
专门为爬虫,首屏渲染内容,前端数据拉取所服务的.为了首屏而生.那么他基本上没有交互后的次生请求,都是第一次发起的.
因此我们可以看出,ssr脚本的编写,虽然必然是重复的,但是他有很强的确定性.我们就像是一个导演,我们正在自编自导一部专门表演给爬虫还有首屏用户的一个页面.一个用户进入一个页面需要进行的一系列操作,都是确定的,顺序的,必然会发生的.
因此他虽然重复,但是好写.
因此要求我们什么?最理想的情况就是,除了调用的那一行代码以外,其他所有的代码都是纯函数,都是脱离于执行环境的.实际上肯定不可能,前端拿到的请求结果,需要dispatch到store中.
而我们在node端,都是拿好请求结果,赶紧扔给redux,再在最后交还给html完成数据注入.两个逻辑完全不一样.
3)在两端都会发生,都会需要他们发生的请求

多余的请求不好规避
页面才不管数据从哪里来呢(这块我没法规避,页面不发起ajax.
其实可以优化的是,当ssr过程没有结束的时候,只要库中已经有了,就不进行再次请求.没做的原因是....我个人觉得,页面只要出来了,可能多发个请求我就可以接受)






---

前面提到,所有的请求性质的数据和行为,都保存在了store中,那么究竟为什么要这样做?假设我们要做ssr.我们至少要满足什么条件？

1)我肯定需要将状态和渲染剥离,我需要一些纯组件,来完成数据注入渲染.如果组件不纯，你怎么通过数据就驾驭他们的展示效果呢？
（这个其实不对，因为没有副作用的执行时间，所以不管他们是否纯，他们都是执行render。）
（这块应该说，能让整个app达成data + function = view。那这就要求，所有的页面，不自己控制state。或者说，所有自己持有的state，我都无法
进行ssr渲染，因为我根本控制不到。）

（
其实我写这个架构的原因是因为，我们项目中有相同的请求，每次都在页面里定义一遍state的行为，令人发指。
虽然我那时候入行也就几个月，我没能力解决这个问题，但是我不断再想办法解决，因为他让整个app丑陋。
后来我想到了比较粗暴的方法，就是将所有的server请求代码剥离+所有的请求数据都放到全局中进行管理。这个思路是可以解决复用的问题的

其实这个思路，也是解决ssr的办法。
）

2)因为我在服务端,是没办法在页面上发起请求的,数据是我单独组织好,从最顶层注入进去的.因此,我必须有全局层面的数据存储渲染层.
3)我需要尽可能复用一些请求.还有数据处理,因为这部分代码是必然需要重写的
4)杜绝代码侵入.让ssr的代码可以随时离开.至少不会引入bug

SEO的本质是，浏览器有一个disable的模式，开启了之后，就是爬虫视角。要始终记住的就是，爬虫是不喜欢js的。因此他没有办法运行onClick回调


----

其他细节
1）如何拆分代码。
这里有一个share的概念，

首先，SSR的代码肯定需要在server端运行。
但是往往SEO首屏的复杂度是有限的，我们需要多少动态内容，就运行多少接口。然后把这些接口返回给Client端
因此我们应该尽量复用server。这样在server端就能用最少的代码，拉到最终符合store要求的数据。

2）如何根据请求判断机型来渲染
在req.header中有agent相关信息

3)如何优化性能.
类比node模块,模块在加载后,会放到cache中.require首先会去找cache.
对于首页,这么做就很划算.因为请求量最大.
因此,一个固定的url,不同用户在一定时间范围内访问,会得到相同的结果


3）如何控制非SSR渲染的页面。
并不是所有页面ssr都有意义。
可以从routerConfig中配置一下。非SSR页面，可以返回一个相同的loading页面。
也就是当没有组件需要渲染的时候，我们可以在html上面插入一段入口等待的页面。

或者干脆的就不做任何处理，就是一个白屏而已。反正如果不做ssr也是白屏

4)从架构说起,为什么多仓库有好处?或者说,为什么将请求数据放到context中有好处?

多仓库，如果能用单仓库，我是绝对不会用多仓库的，我觉得多仓库不好。
1）你得定义一堆的store。真烦。我要最简化。
2）你面对注入，时间机器，这种需求，就是不好。
3）你得注入得到每一个store里面折腾，不好。


5)可以思考下,next是如何如此优雅的实现的?