## 划分，browser，server还有share
前两个仅仅是两个入口文件，差异仅仅是路由不一样。
share就是app组件。最外层就是proider -> switch -> route
前端的入口文件：
后端的入口文件：

这里面主要得说下webpack的一些基本配置，稍微有点麻烦


## 概述
SSR只是最后一个步骤，最后一个环节。
SSR的本质是，我们知道，React是JS渲染出来的，也就是js通过执行createElement，将json转化为dom，最终替换掉根节点root，来达成js渲染dom的目的。那么当js没有执行的时候，实际上我们的index.html是一个空页面。
SSR就是在服务端，执行了js代码，来未卜先知的将预期的页面渲染出来。这样前端拿到的不再是一个空的HTML，而是一个，会根据用户路由，特定渲染出来特定页面的，有血有肉甚至还有请求数据的HTML。
它分为几个步骤。
1）路由匹配阶段，获取页面，获取同构函数ssr.js。
2）调用页面请求，获得数据(需要手写)
3）注入数据，进行server端渲染
4）最后将数据注入到HTML中，HTML作为信使，将内容带回client
5）前端承接ssrData，用同样的组件，进行解析，传入到各个store中。

一个React应用就是一个大递归函数，传入数据，就会渲染出固定的视图。在client，我们通过请求，用户交互来获取数据。而在server端，我们通过设置store来实现页面的渲染。
react帮我解决了funciton的同构。保证前后端渲染的string是一样的的
我们则需要解决data的提供
有了data和function我们就能拿到相同的view，就能让我服务器未卜先知的知道，浏览器经济将渲染出来的结果，从而提前返回给浏览器。



## 路由匹配，获取目标组件，还有ssr.js
这个就是用routerConfig配合useMatch做路由匹配。找到target.
然后发起请求即可。


## 服务端发起，获得data
执行一个很简单的js，去把所有数据都异步的获取好。

> 这块我写的时候遇到障碍，就是我理解不了为什么toString无法执行类的生命周期函数。
React中的大部分函数，在服务端不会执行。

然后返回一个json，进行后续的使用。

## 服务端，用data，通过function得到view1
现在我们有了通过ssr.js获得的请求。再加上匹配到的Page，我们就可以从路由入口，将数据扔进去。

function + data = view。
我们拿到了一个静态的view。


## 后续一些操作
我们先获取了html模板，然后将view写到了app里面。
例如设定title，meta标签。不赘述


## 通过html将data传过去
在script的最后。这里面有个细节，必须放在main.js之前。不然会有问题
设定好了之后，server端的任务就完成了。

很简单，
路由匹配获取ssr.js -> await ssr.js 获取data -> data + funciton 获取view -> html模板 + view + data 返回给前端

## 前端获取，data
用户拿到了html文件，加载出来了。然后开始加载body尾部的打包文件。
我们进入到了前端的入口文件
打包文件加载完毕，最开始执行的就是脱水。
我们的数据通过html主导了window.SSRDATA之中。这里面取出来。


## 渲染（6. 前端，用相同的data，通过相同的function，得到相同的view1）
然后，我们和后端一样，调用了位于share的app根节点。并且把从后端拿到的store data原封不动的扔进去。
那么相同的data + 相同的app funciton 必然得到 = 相同的view。这就是同构的精华。

## 这里面有坑一直没说，顶层注入的data，被众多store监听，消费，渲染。
data注入就能渲染页面，不是说说就完的，那得设计。
这里面的细节在第二篇文章已经提到了，不赘述。

1）如何让所有的子仓库，获得ssrData？
三大戒指归属天下精灵诸君，七大戒指归属石厅矮人列王，九枚戒指归属于阳寿可数的凡人，还有一枚归属于高居御座的黑魁首。莫都大地黑影幢幢。一枚戒指统领众戒，尽归罗网。

这块借鉴了flux，在flux里面，虽然有众多的store，但是有一个controller在上面统帅着所有人。类比一下，这里实际上每个store，都监听了一个名为SSRDATA的顶层store
更准确的说，使用useGetSSRDATAHook来执行，在reducer初始化的时候，将数据进行初始化注入。


注入了之后，data会被一个名为getSsrDataFromStore的仓库持有。初始化掉（获取全部数据）
每个store，在初始化的时候，都拉一下。如果有数据，就传入进去，就这么简单。（将所需要的数据merge到store中）
因为ssr.js返回的数据，里面的结构和store保存的结构是相同一致的。只要告知地址（store的名称）就可以遍历到，然后初始化。


## end 哪些是同构的？ 那些不是同构的。
到目前为止，都是同构的
function是同构的。view视图是同构的。

下一秒后的副作用，就不同勾了。也不需要同构。ssr只是一个静态的，一瞬间的事情。
副作用不同构。
例如发起请求
设置window啥的。


其他细节
为什么前端 后端都需要注入数据？
不仅都要注入，而且数据必须相同。这样才能保证渲染出来一样的结果。


我的疑问。
1. react是怎么在现成的html里面，辨识出来组件的，而不是重新渲染他们。
2. 为什么如果前后端的dom结构又不一样，最终的结果会错乱。
3. 为什么不能将同构的范围，扩大到生命周期，主要是接口的请求和渲染？
这事挺方便的倒是，但我觉得怪怪的。
因为SEO在node端分为两个阶段.对于浏览器来说,生命周期,拉取,都是异步的.
对于node ssr来说,全部都是同步的.所以这两个事情根本没办法同构
(那有没有可能实现server请求也同构呢?因为逻辑并不相同.所以没必要.
server端不能执行全部钩子背后的原因其实我并不清楚
 但是我觉得这种数据+view = function的方式挺好的)

反正结论就是实现不了：我们没办法在renderToString里面有异步操作。他就是瀑布渲染
一次的感觉。没的商量。

而且，其实虽然说data是相同的，但是前后端对于这个data的形成是截然不同的方式。
前端是用户触发的（例如点击，进入页面）
后端是条件的，路由的。你访问我这个url，就得到这个渲染结果。
因此究竟如何组织数据，本来就是前后端各自分离的，各自不同的剧本。请求过程不应该被同构


唯一无法同构的部分,被我分出来了一个ssr.js文件,让他在Node端运行的时候,可以提前获得Redux所需要的数据,从而填充进去完成渲染.


并且因为server还有纯函数的抽象,他将业务逻辑中的绝大部分,都剥离了,只需要进行最简单的调用.

因为client通过dispatch达成.
server是一个命令式的流程链.一个是整理后传出为store然后注入.我们得不到store dispatch的帮助。因为根本就执行不到，他基本上就是同步执行。你只能通过async来组织逻辑.简单来说,ssr的数据流转,和app不太一样.
所以不得不进行纯化.也就是,server和业务逻辑,都需要进行大量的抽象.


这就是全局context的最大作用。

1）data是唯一入口，相同的data就有相同的结果。
2）context是app状态流转的唯一执行人
3）尽可能的同构掉所有的业务函数，越多复用性越高。无法同构的仅仅有那一行调用的发起代码。



## 部署
部署就很简单了
1. nginx监听80端口 将所有/ 请求转发到 3000ssr 将/api转发到业务上
2. ssr会获取build的html模板。需要配置一下static。

如果你没有部署过服务器，那也没关系。。。你可以本地 build，上面这些流程也都能跑到。
我提供了一个demo，运行./test就可以通过8080访问ssr的react的项目工程。
项目基于antd-5 react-router-5 cra3 eject less使用context作为store管理方案 并实现ssr。里面有这3个文章的实现。可以借鉴。

如果你想部署到阿里云上面。这里面也有篇 搭建服务器的文章

这篇文章，我个人觉得一个系列，算是比较满意了。而且我也的确抽离了一个脚手架。而且我对这个脚手架，也有很多愿望。希望能够提高我的
开发效率。
但是完全写完文章还有脚手架 得花点功夫 慢慢来。